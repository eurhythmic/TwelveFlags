//
//  ScoreRepository.swift
//  TwelveFlags
//
//  Created by RnD on 12/28/20.
//

import FirebaseFirestore
import FirebaseFirestoreSwift
import Combine

class ScoreRepository: ObservableObject {
    private let path: String = "scores"
    private let store = Firestore.firestore()
    @Published var scores: [Score] = []
    // Stores the current user id generated by Firebase
    var userId = ""
    private let authenticationService = AuthenticationService()
    private var cancellables: Set<AnyCancellable> = []
    
    init() {
        authenticationService.$user.compactMap { user in
            user?.uid
        }
        .assign(to: \.userId, on: self)
        .store(in: &cancellables)
        
        authenticationService.$user
            // Set the thread where code will execute
            .receive(on: DispatchQueue.main)
            // Ensures that when you get a `user` from `AuthenticationService`, the closure executes in the main thread
            .sink { [weak self] _ in
                self?.get()
            }
            .store(in: &cancellables)
    }
    
    func get() {
        store.collection(path)
            // Filter scores by `highScore` in descending order, with a maximum number of items to return
            .order(by: "highScore", descending: true).limit(to: 20)
            // Add a listener to receive changes in the collection
            .addSnapshotListener { querySnapshot, error in
                if let error = error {
                    print("Error getting scores: \(error.localizedDescription)")
                    return
                }
                
                // Using compactMap, iterate over all the elements in querySnapshot.documents
                self.scores = querySnapshot?.documents.compactMap { document in
                    // Map every document as a `Score` using `data`
                    try? document.data(as: Score.self)
                } ?? []
            }
    }
    
    func add(_ score: Score) {
        do {
            var newScore = score
            newScore.userId = userId
              _ = try store.collection(path).addDocument(from: newScore)
        } catch {
            fatalError("Unable to add score: \(error.localizedDescription).")
        }
    }
    
    func update(_ score: Score) {
        guard let scoreID = score.userId else {
            return
        }
        
        do {
            try store.collection(path).document(scoreID).setData(from: score)
        } catch {
            fatalError("Unable to update score: \(error.localizedDescription).")
        }
    }
    
    func remove(_ score: Score) {
        guard let scoreID = score.userId else {
            return
        }
        
        store.collection(path).document(scoreID).delete { error in
            if let error = error {
                print("Unable to remove score: \(error.localizedDescription).")
            }
        }
    }
}
